#!/usr/bin/env node

require('colors')

const path   = require('path')
const semver = require('semver')
const ora    = require('ora')
const cp     = require('pn/child_process')
const fs     = require('pn/fs')
const prompt = require('inquirer').createPromptModule()

if (!process.env.npm_package_name) {
  console.log('\nMake sure you run this as npm script'.yellow)
  process.exit(1)
}

const argv = require('minimist')(process.argv.slice(1), {
  default: {
    debug      : process.env.LOG_LEVEL === 'info' || false,
    tests      : true,
    master     : true,
    from       : process.env.npm_package_version,
    dry        : false,
    build      : !!process.env.npm_package_scripts_build,
    push       : null,
    publish    : null,
    changelog  : 'markers:FEATURE,FIX,DEV',
    changefile : 'CHANGELOG.md'
  }
})

if (argv.h || argv.help) {
  console.log(`
Publishing script. Automates following steps:

  - check environment setup
  - assemple a change log from from git history
  - bump the package version and tag it
  - push to remote git repository
  - publish to npm registry

${'Usage'.bold}

  ${path.basename(__filename)} [options]

${'Options'.bold}

  --debug           Show shell commands debugging

  --dry             Do not run git commit/puash, do not write package.json,
                    npm build would be still ran as normal

  --changelog       Define how to assemble changelog from git history. Values:

                    markers:MARKER1,...,MARKERN

                      Default, bilt-in, matchs through entire commit description
                      collecting the lines starting with listed markers.
                      By default markers:FEATURE,FIX,DEV

                    raw

                      Built-in, collects all commit subjects (git log --pretty=format:%s)

                    *

                      Custom node module path to be require()'d and provide
                      function returning lines array

  --changefile      Changelog file name in CWD.
                    By default CHANGELOG.md

  --from            Current package version before bumped,
                    start point for reading git log

  --no-master       Do not require to publish only from master branch

  --no-build        Skip the build step, skipping by default if there is no
                    scripts.build defined in package.json

  --no-tests        Skip "npm test" step

  --[no-]push       Enforce all changes [not] to be pushed to default remote git repo,
                    user will be prompted if omitted

  --[no-]publish    Enforce package to [not] be pushed to npm registry,
                    user will be prompted if omitted
  `)
  process.exit(0)
}

const skip = new Error()

function exec (cmd, split, statusMessage = null) {
  const spinner = statusMessage ? ora(statusMessage) : null

  if (spinner) {
    console.log()
    spinner.start()
  }

  return new Promise((resolve, reject) => {
    return cp.exec(cmd).promise.then(res => {
      if (spinner) spinner.stop()
      res = res.stdout.trim()
      if (argv.debug) console.log('> %s\n\n%s\n\n', cmd, res.gray)
      resolve(split
        ? res.split('\n').map(s => s.trim()).filter(s => !!s)
        : res)
    })
    .catch(err => {
      if (spinner) spinner.stop()
      reject(err)
    })
  })
}

function ok () {
  return argv.dry ? '[dry]'.yellow : '✔︎'.green
}

function truncate (s, length) {
  return s.length <= length ? s : s.slice(0, length) + '…'
}

// ----- changelog sources ------

const changelogSources = {
  raw: () => {
    return exec(`git log --pretty=format:'%s' ${prevVersion}..${currentBranch}`, true)
      .then(lines => {
        if (lines.length === 0) console.log(`No commits since ${prevVersion}!`.yellow)
        return lines
      })
  },

  markers: markers => {
    markers = markers.split(',')
    const re = new RegExp(`^\s*(${markers.join('|')})`)
    return exec(`git log --pretty=format:'%B' ${prevVersion}..${currentBranch}`, true)
      .then(lines => lines.filter(line => re.test(line)))
      .then(lines => {
        _advise(`\nNo commits marked with ${markers.join(', ')}`,
          'try to run with --changelog=raw')
        return lines
      })
  }
}

// ----- collected data -----

const prevVersion = argv.from

let nextVersion = prevVersion
let currentBranch = 'master'
let suggestedType = 'patch'
let changelogContent = ''
let releaseNotes = ''

// ----- preflight checks -----

function _advise (subject, ...advices) {
  console.log(subject.yellow)
  console.log(`\n${advices.map(a => `  - ${a}`).join('\n')}\n`)
}

function _checkGit (promise) {
  return new Promise((resolve, reject) => promise
    .then(resolve)
    .catch(err => {
      if (err.message.indexOf('Not a git repository') !== -1) {
        const command = err.message.split('\n')[0]
        _advise(`${command}. Not a git repo?`,
          'this script is designed to work only with Git')
        return resolve(false)
      }
      reject(err)
    })
  )
}

function checkScript () {
  if (!process.env.npm_package_version) {
    _advise('Can\'t detect current package version',
      'check if the field "version" is defined in package.json')
    return false
  }
  return true
}

function checkPrevVersion () {
  return _checkGit(exec('git tag -l', true)
    .then(tags => {
      if (tags.indexOf(prevVersion) === -1) {
        _advise(`Git tag "${prevVersion}" does not exist`,
          'run `git tag -l` to see available tags')
        return false
      }
      return true
    })
  )
}

function checkDirty () {
  return _checkGit(exec('git status -s', true)
    .then(lines => {
      if (lines.length > 0) {
        _advise('Directory contains uncommitted files',
          'stash, commit, or revert uncommitted files')
        return false
      }
      return true
    }))
}

// ----- steps -----

function getTests () {
  console.log()
  return argv.tests && new Promise((resolve, reject) => {
    exec('npm test -s', false, 'Running tests')
      .then(result => {
        console.log(`Test results:\n\n${result.gray}\n`)
        resolve()
      })
      .catch(reject)
  })
}

function getCurrentBranch () {
  return exec('git rev-parse --abbrev-ref HEAD')
    .then(branch => {
      if (argv.master && branch !== 'master') return prompt({
        name    : 'ok',
        type    : 'confirm',
        message : 'You are not in master branch. Proceed?',
        default : false
      }).then(answer => {
        if (!answer.ok) throw skip
        currentBranch = branch
      })
      currentBranch = branch
    })
}

function getChangelog () {
  const [source, ...params] = argv.changelog.split(':')
  const getRecords = changelogSources[source] || (() => require(source))

  return Promise.resolve()
    .then(() => getRecords(...params))
    .then(list => {
      return list.length === 0 ? prompt({
        name    : 'ok',
        type    : 'confirm',
        message : `Changelog since ${prevVersion} is empty, proceed?`,
        default : false
      }).then(answer => {
        if (!answer.ok) throw skip
        return list
      }) : list
    })
    .then(list => {
      const pick = (list, selected) => {
        console.log()
        return prompt({
          name     : 'selected',
          type     : 'checkbox',
          pageSize : 25,
          message  : `Review the changes since ${prevVersion} (${(list.length + ' items').yellow} total)`,
          choices  : list,
          default  : selected
        }).then(answer => {
          const selected = answer.selected
          changelogContent = answer.selected
            .map(line => `- ${line}`)
            .join('\n') || 'no description'

          console.log()
          return prompt({
            name    : 'ok',
            type    : 'confirm',
            message : `To be prepended to ${argv.changefile}:\n \n${changelogContent.gray}\n \nLooks ok?`,
            default : true
          }).then(answer => {
            if (!answer.ok) return pick(list, selected)
            return selected
          })
        })
      }

      return pick(list, list)
    })
}

function getNextVersion () {
  console.log()
  return prompt({
    name    : 'type',
    type    : 'list',
    message : 'Upgrade type',
    choices : ['patch', 'minor', 'major'],
    default : suggestedType
  }).then(answer => {
    nextVersion = semver.inc(prevVersion, answer.type)
    console.log('\n%s -> %s', prevVersion, nextVersion.green)
  })
}

function writeChangelog () {
  releaseNotes = `# Version ${nextVersion} (${(new Date()).toLocaleString()})\n\n${changelogContent}`
  const filePath = path.resolve(argv.changefile)

  return (new Promise((resolve, reject) => {
    return fs.readFile(filePath, 'utf8')
      .then(resolve)
      .catch(err => {
        if (err.code === 'ENOENT') return resolve('')
        reject(err)
      })
  }))
    .then(content => !argv.dry && fs.writeFile(filePath, `${releaseNotes}\n\n${content}`, 'utf8'))
    .then(() => console.log(`\n${ok()} updated ${argv.changefile}`))
}

function writeBuild () {
  return argv.build && Promise.resolve()
    .then(() => {
      console.log()
      if (!process.env.npm_package_scripts_build) return console.log('No scripts.build'.gray)

      return exec('npm run build', false, 'Building')
        .then(result => console.log(`Build:\n\n${result.gray}\n`))
        .then(() => !argv.dry && exec(`git add . && git commit -am 'build ${nextVersion}'`))
        .then(() => console.log(`${ok()} comitted "build ${nextVersion}"`))
    })
}

function writeVersion () {
  console.log()
  const packageFile = path.resolve('package.json')
  return fs.readFile(packageFile, 'utf8')
    .then(pkg => {
      const nextPackage = Object.assign(JSON.parse(pkg), {version: nextVersion})
      return !argv.dry && fs.writeFile(packageFile, JSON.stringify(nextPackage, null, 2), 'utf8')
    })
    .then(() => {
      console.log(`${ok()} updated package.json`)
      return !argv.dry && exec(`git add ${argv.changefile} && git commit -m "version ${nextVersion}" ${argv.changefile} package.json`)
    })
    .then(() => {
      console.log(`${ok()} comitted "version ${nextVersion}"`)
      return !argv.dry && exec(`git tag -a ${nextVersion} -m "version ${nextVersion}"`)
    })
    .then(() => console.log(`${ok()} created git tag "${nextVersion}"`))
}

function writeRemoteGit () {
  console.log()
  return (argv.push === null
    ? prompt({
        name    : 'ok',
        type    : 'confirm',
        message : 'Push to git remote?',
        default : true
      }).then(answer => answer.ok)
    : Promise.resolve(argv.push)
  ).then(push => {
    return push
      ? Promise.resolve()
          .then(() => !argv.dry && exec('git push && git push --tags', false, 'Pushing'))
          .then(() => console.log(`\n${ok()} pushed all to remote git repo`))
      : console.log('\nSkipping git push,\ndon\'t forget to push manually as `git push && git push --tags`'.gray)
  })
}

function writeNpm () {
  console.log()
  const repo = truncate(process.env.npm_package_publishConfig_registry, 25)
  return (argv.publish === null
    ? prompt({
        name    : 'ok',
        type    : 'confirm',
        message : `Publish to ${repo.yellow} ?`,
        default : true
      }).then(answer => answer.ok)
    : Promise.resolve(argv.publish)
  ).then(publish => {
    return publish
      ? Promise.resolve()
          .then(() => !argv.dry && exec('npm publish', false, 'Publishing'))
          .then(() => console.log(`\n${ok()} published to ${repo}`))
      : console.log('\nSkipping publishing,\ndon\'t forget to publish manually as `npm publish`'.gray)
  })
}

function writeReleaseNotes () {
  console.log()
  console.log(`Release notes:\n \n${releaseNotes.gray}`)
}

// ----- run -----

if (argv.dry) console.log('--- DRY RUN ---\n'.yellow)

Promise.all([
  checkDirty(),
  checkScript(),
  checkPrevVersion()
])
.then(checks => {
  for (let passed of checks) if (!passed) throw skip
})
.then(getCurrentBranch)
.then(getTests)
.then(getChangelog)
.then(getNextVersion)
.then(writeChangelog)
.then(writeBuild)
.then(writeVersion)
.then(writeRemoteGit)
.then(writeNpm)
.then(writeReleaseNotes)
.catch(err => {
  err === skip
    ? console.log('\nSkipping'.gray)
    : console.log('\nSomething happened'.red, err)
  process.exit(1)
})
